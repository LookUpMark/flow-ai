import saveAs from 'file-saver';
import type { ExportFormat, Template, TemplateStyle } from '../types';
import { TEMPLATES } from '../constants';
import { marked } from 'marked';
import { jsPDF } from 'jspdf';
import { Document, Packer, Paragraph, TextRun, HeadingLevel } from 'docx';


// TypeScript declarations for libraries loaded from CDN
declare const docx: any;

const generateSlug = (text: string) => {
    return text
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');
};

const exportMarkdown = (content: string, fileName: string) => {
    const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
    saveAs(blob, `${fileName}.md`);
};

const exportPdf = async (content: string, fileName: string, template: Template) => {
    const { style } = TEMPLATES[template];
    const pdf = new jsPDF({
        unit: 'pt',
        format: 'a4',
    });

    pdf.setFont(style.font, 'normal');
    pdf.setFontSize(style.fontSize);

    const htmlContent = await marked.parse(content.replace(/---[\s\S]*?---/, '')); // Remove YAML frontmatter
    
    // Create a temporary element to render HTML for better PDF conversion
    const element = document.createElement('div');
    element.innerHTML = htmlContent;
    element.style.width = '595pt'; // A4 width in points
    element.style.padding = '20pt';
    element.style.boxSizing = 'border-box';
    element.style.fontFamily = style.font === 'times' ? 'Times-Roman' : 'Helvetica';
    element.style.fontSize = `${style.fontSize}pt`;
    element.style.lineHeight = `${style.lineHeight}`;

    document.body.appendChild(element);

    await pdf.html(element, {
        callback: (doc) => {
            doc.save(`${fileName}.pdf`);
            document.body.removeChild(element);
        },
        x: 0,
        y: 0,
        width: 595, // A4 width
        windowWidth: 595
    });
};

const exportDocx = async (content: string, fileName: string, template: Template) => {
    const { style } = TEMPLATES[template];
    const paragraphs: (Paragraph | any)[] = [];

    const lines = content.replace(/---[\s\S]*?---/, '').split('\n');

    lines.forEach(line => {
        if (line.startsWith('### ')) {
            paragraphs.push(new Paragraph({ heading: HeadingLevel.HEADING_3, children: [new TextRun({ text: line.substring(4), font: { name: style.font === 'times' ? 'Times New Roman' : 'Helvetica' } })], spacing: { after: 120 } }));
        } else if (line.startsWith('## ')) {
            paragraphs.push(new Paragraph({ heading: HeadingLevel.HEADING_2, children: [new TextRun({ text: line.substring(3), font: { name: style.font === 'times' ? 'Times New Roman' : 'Helvetica' } })], spacing: { after: 150 } }));
        } else if (line.startsWith('# ')) {
            paragraphs.push(new Paragraph({ heading: HeadingLevel.HEADING_1, children: [new TextRun({ text: line.substring(2), font: { name: style.font === 'times' ? 'Times New Roman' : 'Helvetica' } })], spacing: { after: 200 } }));
        } else if (line.startsWith('* ')) {
             paragraphs.push(new Paragraph({ text: line.substring(2), bullet: { level: 0 }, style: "default" }));
        } 
        else {
            paragraphs.push(new Paragraph({ children: [new TextRun(line)], style: "default" }));
        }
    });

    const doc = new Document({
        styles: {
            paragraphStyles: [{
                id: "default",
                name: "Default",
                run: {
                    size: style.fontSize * 2, // docx uses half-points
                    font: { name: style.font === 'times' ? 'Times New Roman' : 'Helvetica' },
                },
                paragraph: {
                    spacing: { line: style.lineHeight * 240 } // docx uses 1/240th of a line
                }
            }]
        },
        sections: [{ children: paragraphs }],
    });

    const blob = await Packer.toBlob(doc);
    saveAs(blob, `${fileName}.docx`);
};

const exportLatex = (content: string, fileName:string) => {
    const latexPreamble = `\\documentclass{article}
\\usepackage{geometry}
\\geometry{a4paper, margin=1in}
\\usepackage{amsmath}
\\usepackage{graphicx}
\\usepackage{hyperref}
\\title{${fileName.replace(/-/g, ' ')}}
\\author{Generated by Obsidian Knowledge Architect}
\\date{\\today}

\\begin{document}
\\maketitle

`;
    
    // Basic conversion from Markdown to LaTeX
    let latexContent = content
        .replace(/---[\s\S]*?---/, '') // Remove YAML
        .replace(/## (.*)/g, '\\section*{$1}')
        .replace(/### (.*)/g, '\\subsection*{$1}')
        .replace(/\*\*(.*)\*\*/g, '\\textbf{$1}')
        .replace(/\*(.*)\*/g, '\\textit{$1}')
        // Escape special LaTeX characters
        .replace(/&/g, '\\&')
        .replace(/%/g, '\\%')
        .replace(/\$/g, '\\$')
        .replace(/#/g, '\\#')
        .replace(/_/g, '\\_')
        .replace(/{/g, '\\{')
        .replace(/}/g, '\\}')
        .replace(/~/g, '\\textasciitilde{}')
        .replace(/\^/g, '\\textasciicircum{}');


    const latexPostamble = `
\\end{document}
`;
    
    const fullLatexDoc = `${latexPreamble}${latexContent}${latexPostamble}`;
    const blob = new Blob([fullLatexDoc], { type: 'application/x-latex;charset=utf-8' });
    saveAs(blob, `${fileName}.tex`);
};


export const exportDocument = async (
    format: ExportFormat,
    template: Template,
    content: string,
    topic: string
) => {
    const fileName = generateSlug(topic) || 'exported-note';

    switch (format) {
        case 'markdown':
            exportMarkdown(content, fileName);
            break;
        case 'pdf':
            await exportPdf(content, fileName, template);
            break;
        case 'docx':
            await exportDocx(content, fileName, template);
            break;
        case 'latex':
            exportLatex(content, fileName);
            break;
        default:
            console.error('Unsupported export format');
    }
};